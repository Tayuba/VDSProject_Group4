Index: src/Manager.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// A minimalistic BDD library, following Wolfgang Kunz lecture slides\r\n//\r\n// Created by Markus Wedler 2014\r\n\r\n#ifndef VDSPROJECT_MANAGER_H\r\n#define VDSPROJECT_MANAGER_H\r\n\r\n#include \"ManagerInterface.h\"\r\n#include <vector>\r\n#include \"unordered_map\"\r\n\r\nnamespace ClassProject {\r\n\r\n    class Manager : public ManagerInterface {\r\n\r\n    public:\r\n\r\n        struct BDDnode {\r\n            BDD_ID node_id;\r\n            std::string label;\r\n            BDD_ID high;\r\n            BDD_ID low;\r\n            BDD_ID top;\r\n        };\r\n\r\n\r\n        std::vector<BDDnode> unique_table;\r\n        std::unordered_map<std::string, BDD_ID>computed_table;\r\n        std::unordered_map<std::string, BDD_ID> inverse_table;\r\n\r\n        size_t uniqueTableSize();\r\n        BDD_ID createVar(const std::string &label);\r\n        const BDD_ID &True();\r\n        const BDD_ID &False();\r\n        BDD_ID topVar(BDD_ID f);\r\n        BDD_ID ite(BDD_ID i, BDD_ID t, BDD_ID e);\r\n        bool isConstant(BDD_ID f);\r\n        bool isVariable(BDD_ID x);\r\n        BDD_ID coFactorTrue(BDD_ID f, BDD_ID x);\r\n        BDD_ID coFactorFalse(BDD_ID f, BDD_ID x);\r\n        BDD_ID coFactorTrue(BDD_ID f);\r\n        BDD_ID coFactorFalse(BDD_ID f);\r\n        BDD_ID neg(BDD_ID a);\r\n        BDD_ID and2(BDD_ID a, BDD_ID b);\r\n        BDD_ID or2(BDD_ID a, BDD_ID b);\r\n        BDD_ID xor2(BDD_ID a, BDD_ID b);\r\n        BDD_ID nand2(BDD_ID a, BDD_ID b);\r\n        BDD_ID nor2(BDD_ID a, BDD_ID b);\r\n        BDD_ID xnor2(BDD_ID a, BDD_ID b);\r\n        std::string getTopVarName(const BDD_ID &root);\r\n        void findNodes(const BDD_ID &root, std::set<BDD_ID> &nodes_of_root);\r\n        void findVars(const BDD_ID &root, std::set<BDD_ID> &vars_of_root);\r\n        void update_computed_table(const BDD_ID i, const BDD_ID t, const BDD_ID e, BDD_ID &node_id);\r\n        bool get_computed_table(const BDD_ID i, const BDD_ID t, const BDD_ID e, BDD_ID &nodeID);\r\n        BDD_ID find_or_add_unique_table(BDD_ID highSuccessor, BDD_ID lowSuccessor, BDD_ID topVariable, BDD_ID &node_id);\r\n\r\n\r\n    public:  Manager(){\r\n\r\n            BDDnode F = {0,\"False\",0,0,0};\r\n            BDDnode T = {1,\"True\",1,1,1};\r\n\r\n\r\n\r\n            unique_table.push_back(F);\r\n            unique_table.push_back(T);\r\n\r\n        }\r\n    virtual    ~Manager(){\r\n        unique_table.erase(unique_table.begin());\r\n        }\r\n\r\n    };\r\n\r\n}\r\n\r\n#endif\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Manager.h b/src/Manager.h
--- a/src/Manager.h	(revision e3472c4ee1df7077f2c646113ce27f025d9c234c)
+++ b/src/Manager.h	(date 1643369541993)
@@ -27,6 +27,7 @@
         std::vector<BDDnode> unique_table;
         std::unordered_map<std::string, BDD_ID>computed_table;
         std::unordered_map<std::string, BDD_ID> inverse_table;
+//        std::unordered_map<std::string, BDD_ID> l_Table;
 
         size_t uniqueTableSize();
         BDD_ID createVar(const std::string &label);
@@ -52,7 +53,7 @@
         void findVars(const BDD_ID &root, std::set<BDD_ID> &vars_of_root);
         void update_computed_table(const BDD_ID i, const BDD_ID t, const BDD_ID e, BDD_ID &node_id);
         bool get_computed_table(const BDD_ID i, const BDD_ID t, const BDD_ID e, BDD_ID &nodeID);
-        BDD_ID find_or_add_unique_table(BDD_ID highSuccessor, BDD_ID lowSuccessor, BDD_ID topVariable, BDD_ID &node_id);
+
 
 
     public:  Manager(){
@@ -60,6 +61,12 @@
             BDDnode F = {0,"False",0,0,0};
             BDDnode T = {1,"True",1,1,1};
 
+//            std::string key_f = std::to_string(0) + "_" + std::to_string(0) + "_" + std::to_string(0);
+//            std::string key_t = std::to_string(1) + "_" + std::to_string(1) + "_" + std::to_string(1);
+//
+//            inverse_table.insert({{key_f}, {0}});
+//            inverse_table.insert({{key_t}, {1}});
+
 
 
             unique_table.push_back(F);
Index: src/Manager.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Manager.h\"\r\n#include <algorithm>\r\n\r\n    size_t ClassProject::Manager::uniqueTableSize() {\r\n        return ClassProject::Manager::unique_table.size();\r\n}\r\n\r\n    ClassProject::BDD_ID ClassProject::Manager::createVar(const std::string &label) {\r\n        size_t sizeOfTable = uniqueTableSize();\r\n        for(const auto& i : unique_table) {\r\n            if (i.label == label) {\r\n                return i.node_id;\r\n            }\r\n        }\r\n        Manager::unique_table.push_back(ClassProject::Manager::BDDnode{sizeOfTable, label, 1, 0, sizeOfTable});\r\n        return ClassProject::Manager::unique_table[sizeOfTable].node_id;\r\n\r\n}\r\n\r\n    const ClassProject::BDD_ID &ClassProject::Manager::False(){\r\n        static const BDD_ID FalseID = unique_table[0].node_id;\r\n        return FalseID;\r\n}\r\n\r\n\r\n    const ClassProject::BDD_ID &ClassProject::Manager::True(){\r\n        static const BDD_ID TrueID = unique_table[1].node_id;\r\n        return TrueID;\r\n    }\r\n\r\n\r\n    ClassProject::BDD_ID ClassProject::Manager::topVar(BDD_ID f) {\r\n        return unique_table[f].top;\r\n    }\r\n\r\n    void ClassProject::Manager::update_computed_table(const BDD_ID i,const BDD_ID t, const BDD_ID e, BDD_ID &node_id){\r\n\r\n        std::string key = std::to_string(i) + \"_\" + std::to_string(t) + \"_\" + std::to_string(e);\r\n        computed_table.insert({{key},{node_id}});\r\n\r\n}\r\n\r\n    bool ClassProject::Manager::get_computed_table(const BDD_ID i, const BDD_ID t, const BDD_ID e, BDD_ID &nodeID) {\r\n\r\n        std::string key = std::to_string(i) + \"_\" + std::to_string(t) + \"_\" + std::to_string(e);\r\n\r\n        auto found = computed_table.find(key);\r\n\r\n        if(found != computed_table.end()) {\r\n            nodeID = found->second;\r\n            return true;\r\n        }\r\n        return false;\r\n}\r\n\r\n    ClassProject::BDD_ID ClassProject::Manager::ite(BDD_ID i, BDD_ID t, BDD_ID e){\r\n\r\n        std::set<BDD_ID> topVariables;\r\n        BDD_ID topVariable;\r\n        BDD_ID highSuccessor;\r\n        BDD_ID lowSuccessor;\r\n        BDDnode newNode;\r\n        size_t tableSize ;\r\n        BDDnode existingNode;\r\n        BDD_ID nodeID;\r\n\r\n        //terminal cases\r\n        if (i == True()) {\r\n            return t;\r\n        }\r\n        else if (i == False()) {\r\n            return e;\r\n        }\r\n        else if(t == e) {\r\n            return t;\r\n        }\r\n        else if(t == True() && e == False()) {\r\n            return i;\r\n        }\r\n        //computed table\r\n\r\n        else if(get_computed_table(i,t,e, nodeID))\r\n        {\r\n            return nodeID;\r\n        }\r\n        else{\r\n            topVariables={topVar(i), topVar(t), topVar(e)};\r\n            topVariables.erase(0);\r\n            topVariables.erase(1);\r\n            topVariable = *(--topVariables.rend());\r\n\r\n            highSuccessor=ite(coFactorTrue(i,topVariable), coFactorTrue(t,topVariable), coFactorTrue(e,topVariable));\r\n            lowSuccessor=ite(coFactorFalse(i,topVariable), coFactorFalse(t,topVariable), coFactorFalse(e,topVariable));\r\n\r\n            if(highSuccessor==lowSuccessor)\r\n                return highSuccessor;\r\n\r\n            tableSize = uniqueTableSize();\r\n            newNode = {tableSize,\"\",highSuccessor,lowSuccessor,topVariable};\r\n\r\n            std::string key_r = std::to_string(highSuccessor) + \"/\" + std::to_string(lowSuccessor) + \"/\" + std::to_string(topVariable);\r\n\r\n            auto alreadyIn = inverse_table.find(key_r);\r\n\r\n            if(alreadyIn != inverse_table.end()) {\r\n                nodeID = alreadyIn->second;\r\n                return nodeID;\r\n            }\r\n\r\n            inverse_table.insert({{key_r},{newNode.node_id}});\r\n\r\n            ClassProject::Manager::unique_table.push_back(newNode);\r\n            update_computed_table(i,t,e,newNode.node_id);\r\n            return newNode.node_id;\r\n\r\n    }\r\n}\r\n\r\n    bool ClassProject::Manager::isConstant(BDD_ID f){\r\n        if(f==0 || f==1)\r\n            return true;\r\n        else\r\n            return false;\r\n}\r\n\r\n    bool ClassProject::Manager::isVariable(BDD_ID x){\r\n        if(unique_table[x].label !=\"False\" && unique_table[x].label !=\"True\" && !unique_table[x].label.empty())\r\n            return true;\r\n        else\r\n            return false;\r\n}\r\n\r\n    ClassProject::BDD_ID ClassProject::Manager::coFactorTrue(BDD_ID f, BDD_ID x){\r\n        BDD_ID F, T;\r\n\r\n        if (isConstant(f) || isConstant(x) || ClassProject::Manager::unique_table[f].top > x)\r\n            return f;\r\n        if(topVar(f)==x)\r\n            return unique_table[f].high;\r\n        else {\r\n            F = coFactorTrue(unique_table[f].low, x);\r\n            T = coFactorTrue(unique_table[f].high, x);\r\n\r\n            return ite(topVar(f), T, F);\r\n        }\r\n}\r\n\r\n    ClassProject::BDD_ID ClassProject::Manager::coFactorFalse(BDD_ID f, BDD_ID x){\r\n        BDD_ID F, T;\r\n\r\n        if (isConstant(f) || isConstant(x) || ClassProject::Manager::unique_table[f].top > x)\r\n            return f;\r\n        if(topVar(f)==x)\r\n            return unique_table[f].low;\r\n        else {\r\n            F = coFactorFalse(unique_table[f].low, x);\r\n            T = coFactorFalse(unique_table[f].high, x);\r\n\r\n            return ite(topVar(f), T, F);\r\n        }\r\n}\r\n\r\n    ClassProject::BDD_ID ClassProject::Manager:: coFactorTrue(BDD_ID f){\r\n\r\n        return ClassProject::Manager::unique_table[f].high;\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager:: coFactorFalse(BDD_ID f){\r\n\r\n        return ClassProject::Manager::unique_table[f].low;\r\n\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager::neg(BDD_ID a) {\r\n\r\n        return ite(a, 0, 1);\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager::and2(BDD_ID a, BDD_ID b){\r\n\r\n        return ite(a, b, 0);\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager::or2(BDD_ID a, BDD_ID b){\r\n\r\n        return ite(a, 1, b);\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager::xor2(BDD_ID a, BDD_ID b){\r\n//        BDD_ID negB = neg(b);\r\n        return ite(a, neg(b), b);\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager::nand2(BDD_ID a, BDD_ID b){\r\n        return neg(and2(a, b));\r\n\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager::nor2(BDD_ID a, BDD_ID b){\r\n        BDD_ID Or = or2(a, b);\r\n        BDD_ID nor = neg(Or);\r\n        return nor;\r\n}\r\n    ClassProject::BDD_ID ClassProject::Manager::xnor2(BDD_ID a, BDD_ID b){\r\n        BDD_ID Xor = xor2(a, b);\r\n        BDD_ID xnor = neg(Xor);\r\n        return xnor;\r\n}\r\n\r\n    std::string ClassProject::Manager::getTopVarName(const BDD_ID &root) {\r\n        BDD_ID topVariable = topVar(root);\r\n        return ClassProject::Manager::unique_table[topVariable].label;\r\n}\r\n    void ClassProject::Manager::findNodes(const BDD_ID &root, std::set<BDD_ID> &nodes_of_root) {\r\n        nodes_of_root.insert(root);\r\n        if(root > 1) {\r\n            findNodes(coFactorTrue(root), nodes_of_root);\r\n            findNodes(coFactorFalse(root), nodes_of_root);\r\n        }\r\n\r\n}\r\n\r\n    void ClassProject::Manager::findVars(const BDD_ID &root, std::set<BDD_ID> &vars_of_root) {\r\n        std::set<BDD_ID> nodes;\r\n        findNodes(root, nodes);\r\n        nodes.erase(1);\r\n        nodes.erase(0);\r\n        for(auto x: nodes){\r\n            vars_of_root.insert(topVar(x));\r\n        }\r\n\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Manager.cpp b/src/Manager.cpp
--- a/src/Manager.cpp	(revision e3472c4ee1df7077f2c646113ce27f025d9c234c)
+++ b/src/Manager.cpp	(date 1643368681815)
@@ -1,226 +1,244 @@
 #include "Manager.h"
 #include <algorithm>
 
-    size_t ClassProject::Manager::uniqueTableSize() {
-        return ClassProject::Manager::unique_table.size();
+size_t ClassProject::Manager::uniqueTableSize() {
+    return ClassProject::Manager::unique_table.size();
 }
 
-    ClassProject::BDD_ID ClassProject::Manager::createVar(const std::string &label) {
-        size_t sizeOfTable = uniqueTableSize();
-        for(const auto& i : unique_table) {
-            if (i.label == label) {
-                return i.node_id;
-            }
-        }
-        Manager::unique_table.push_back(ClassProject::Manager::BDDnode{sizeOfTable, label, 1, 0, sizeOfTable});
-        return ClassProject::Manager::unique_table[sizeOfTable].node_id;
+ClassProject::BDD_ID ClassProject::Manager::createVar(const std::string &label) {
+    size_t sizeOfTable = uniqueTableSize();
+//    auto l = l_Table.find(label);
+//    if(l != l_Table.end()) {
+//        BDD_ID nodeID = l->second;
+//        return nodeID;
+//    }
+//
+//    l_Table.insert({{label},{sizeOfTable}});
+
+    for(const auto& i : unique_table) {
+        if (i.label == label) {
+            return i.node_id;
+        }
+    }
+//    std::string key_l = std::to_string(1) + "_" + std::to_string(0) + "_" + std::to_string(sizeOfTable);
+//    inverse_table.insert({{key_l}, {sizeOfTable}});
+    Manager::unique_table.push_back(ClassProject::Manager::BDDnode{sizeOfTable, label, 1, 0, sizeOfTable});
+    return ClassProject::Manager::unique_table[sizeOfTable].node_id;
 
 }
 
-    const ClassProject::BDD_ID &ClassProject::Manager::False(){
-        static const BDD_ID FalseID = unique_table[0].node_id;
-        return FalseID;
+const ClassProject::BDD_ID &ClassProject::Manager::False(){
+    static const BDD_ID FalseID = unique_table[0].node_id;
+    return FalseID;
 }
 
 
-    const ClassProject::BDD_ID &ClassProject::Manager::True(){
-        static const BDD_ID TrueID = unique_table[1].node_id;
-        return TrueID;
-    }
+const ClassProject::BDD_ID &ClassProject::Manager::True(){
+    static const BDD_ID TrueID = unique_table[1].node_id;
+    return TrueID;
+}
 
 
-    ClassProject::BDD_ID ClassProject::Manager::topVar(BDD_ID f) {
-        return unique_table[f].top;
-    }
+ClassProject::BDD_ID ClassProject::Manager::topVar(BDD_ID f) {
+    return unique_table[f].top;
+}
 
-    void ClassProject::Manager::update_computed_table(const BDD_ID i,const BDD_ID t, const BDD_ID e, BDD_ID &node_id){
+void ClassProject::Manager::update_computed_table(const BDD_ID i,const BDD_ID t, const BDD_ID e, BDD_ID &node_id){
 
-        std::string key = std::to_string(i) + "_" + std::to_string(t) + "_" + std::to_string(e);
-        computed_table.insert({{key},{node_id}});
+    std::string key = std::to_string(i) + "_" + std::to_string(t) + "_" + std::to_string(e);
+    computed_table.insert({{key},{node_id}});
 
 }
 
-    bool ClassProject::Manager::get_computed_table(const BDD_ID i, const BDD_ID t, const BDD_ID e, BDD_ID &nodeID) {
+bool ClassProject::Manager::get_computed_table(const BDD_ID i, const BDD_ID t, const BDD_ID e, BDD_ID &nodeID) {
 
-        std::string key = std::to_string(i) + "_" + std::to_string(t) + "_" + std::to_string(e);
+    std::string key = std::to_string(i) + "_" + std::to_string(t) + "_" + std::to_string(e);
 
-        auto found = computed_table.find(key);
+    auto found = computed_table.find(key);
 
-        if(found != computed_table.end()) {
-            nodeID = found->second;
-            return true;
-        }
-        return false;
+    if(found != computed_table.end()) {
+        nodeID = found->second;
+        return true;
+    }
+    return false;
 }
 
-    ClassProject::BDD_ID ClassProject::Manager::ite(BDD_ID i, BDD_ID t, BDD_ID e){
+
+ClassProject::BDD_ID ClassProject::Manager::ite(BDD_ID i, BDD_ID t, BDD_ID e){
 
-        std::set<BDD_ID> topVariables;
-        BDD_ID topVariable;
-        BDD_ID highSuccessor;
-        BDD_ID lowSuccessor;
-        BDDnode newNode;
-        size_t tableSize ;
-        BDDnode existingNode;
-        BDD_ID nodeID;
+    std::set<BDD_ID> topVariables;
+    BDD_ID topVariable;
+    BDD_ID highSuccessor;
+    BDD_ID lowSuccessor;
+    BDDnode newNode;
+    size_t tableSize ;
+    BDDnode existingNode;
+    BDD_ID nodeID;
 
-        //terminal cases
-        if (i == True()) {
-            return t;
-        }
-        else if (i == False()) {
-            return e;
-        }
-        else if(t == e) {
-            return t;
-        }
-        else if(t == True() && e == False()) {
-            return i;
-        }
+    //terminal cases
+    if (i == True()) {
+        return t;
+    }
+    else if (i == False()) {
+        return e;
+    }
+    else if(t == e) {
+        return t;
+    }
+    else if(t == True() && e == False()) {
+        return i;
+    }
         //computed table
 
-        else if(get_computed_table(i,t,e, nodeID))
-        {
-            return nodeID;
-        }
-        else{
-            topVariables={topVar(i), topVar(t), topVar(e)};
-            topVariables.erase(0);
-            topVariables.erase(1);
-            topVariable = *(--topVariables.rend());
+    else if(get_computed_table(i,t,e, nodeID))
+    {
+        return nodeID;
+    }
+    else{
+        topVariables={topVar(i), topVar(t), topVar(e)};
+        topVariables.erase(0);
+        topVariables.erase(1);
+        topVariable = *(--topVariables.rend());
 
-            highSuccessor=ite(coFactorTrue(i,topVariable), coFactorTrue(t,topVariable), coFactorTrue(e,topVariable));
-            lowSuccessor=ite(coFactorFalse(i,topVariable), coFactorFalse(t,topVariable), coFactorFalse(e,topVariable));
+        highSuccessor=ite(coFactorTrue(i,topVariable), coFactorTrue(t,topVariable), coFactorTrue(e,topVariable));
+        lowSuccessor=ite(coFactorFalse(i,topVariable), coFactorFalse(t,topVariable), coFactorFalse(e,topVariable));
 
-            if(highSuccessor==lowSuccessor)
-                return highSuccessor;
+        if(highSuccessor==lowSuccessor){
+            return highSuccessor;
+        }
+
 
-            tableSize = uniqueTableSize();
-            newNode = {tableSize,"",highSuccessor,lowSuccessor,topVariable};
+        tableSize = uniqueTableSize();
+        newNode = { tableSize,"",highSuccessor,lowSuccessor,topVariable};
 
-            std::string key_r = std::to_string(highSuccessor) + "/" + std::to_string(lowSuccessor) + "/" + std::to_string(topVariable);
+        std::string key_r = std::to_string(highSuccessor) + "_" + std::to_string(lowSuccessor) + "_" + std::to_string(topVariable);
 
-            auto alreadyIn = inverse_table.find(key_r);
+        auto alreadyIn = inverse_table.find(key_r );
 
-            if(alreadyIn != inverse_table.end()) {
-                nodeID = alreadyIn->second;
-                return nodeID;
-            }
+        if(alreadyIn != inverse_table.end()) {
+            nodeID = alreadyIn->second;
+            return nodeID;
+        }
 
-            inverse_table.insert({{key_r},{newNode.node_id}});
+        inverse_table.insert({{key_r},{newNode.node_id}});
 
-            ClassProject::Manager::unique_table.push_back(newNode);
-            update_computed_table(i,t,e,newNode.node_id);
-            return newNode.node_id;
+        ClassProject::Manager::unique_table.push_back(newNode);
+        update_computed_table(i,t,e,newNode.node_id);
+        return newNode.node_id;
 
     }
 }
 
-    bool ClassProject::Manager::isConstant(BDD_ID f){
-        if(f==0 || f==1)
-            return true;
-        else
-            return false;
+
+bool ClassProject::Manager::isConstant(BDD_ID f){
+    if(f==0 || f==1)
+        return true;
+    else
+        return false;
 }
 
-    bool ClassProject::Manager::isVariable(BDD_ID x){
-        if(unique_table[x].label !="False" && unique_table[x].label !="True" && !unique_table[x].label.empty())
-            return true;
-        else
-            return false;
+bool ClassProject::Manager::isVariable(BDD_ID x){
+//    if((!isConstant(x)) && (unique_table[x].label != ""))
+//        return true;
+//    else
+//        return false;
+//    }
+    if(unique_table[x].label !="False" && unique_table[x].label !="True" && !unique_table[x].label.empty())
+        return true;
+    else
+        return false;
 }
 
-    ClassProject::BDD_ID ClassProject::Manager::coFactorTrue(BDD_ID f, BDD_ID x){
-        BDD_ID F, T;
+ClassProject::BDD_ID ClassProject::Manager::coFactorTrue(BDD_ID f, BDD_ID x){
+    BDD_ID F, T;
 
-        if (isConstant(f) || isConstant(x) || ClassProject::Manager::unique_table[f].top > x)
-            return f;
-        if(topVar(f)==x)
-            return unique_table[f].high;
-        else {
-            F = coFactorTrue(unique_table[f].low, x);
-            T = coFactorTrue(unique_table[f].high, x);
+    if (isConstant(f) || isConstant(x) || ClassProject::Manager::unique_table[f].top > x)
+        return f;
+    if(topVar(f)==x)
+        return unique_table[f].high;
+    else {
+        F = coFactorTrue(unique_table[f].low, x);
+        T = coFactorTrue(unique_table[f].high, x);
 
-            return ite(topVar(f), T, F);
-        }
+        return ite(topVar(f), T, F);
+    }
 }
 
-    ClassProject::BDD_ID ClassProject::Manager::coFactorFalse(BDD_ID f, BDD_ID x){
-        BDD_ID F, T;
+ClassProject::BDD_ID ClassProject::Manager::coFactorFalse(BDD_ID f, BDD_ID x){
+    BDD_ID F, T;
 
-        if (isConstant(f) || isConstant(x) || ClassProject::Manager::unique_table[f].top > x)
-            return f;
-        if(topVar(f)==x)
-            return unique_table[f].low;
-        else {
-            F = coFactorFalse(unique_table[f].low, x);
-            T = coFactorFalse(unique_table[f].high, x);
+    if (isConstant(f) || isConstant(x) || ClassProject::Manager::unique_table[f].top > x)
+        return f;
+    if(topVar(f)==x)
+        return unique_table[f].low;
+    else {
+        F = coFactorFalse(unique_table[f].low, x);
+        T = coFactorFalse(unique_table[f].high, x);
 
-            return ite(topVar(f), T, F);
-        }
+        return ite(topVar(f), T, F);
+    }
 }
 
-    ClassProject::BDD_ID ClassProject::Manager:: coFactorTrue(BDD_ID f){
+ClassProject::BDD_ID ClassProject::Manager:: coFactorTrue(BDD_ID f){
 
-        return ClassProject::Manager::unique_table[f].high;
+    return ClassProject::Manager::unique_table[f].high;
 }
-    ClassProject::BDD_ID ClassProject::Manager:: coFactorFalse(BDD_ID f){
+ClassProject::BDD_ID ClassProject::Manager:: coFactorFalse(BDD_ID f){
 
-        return ClassProject::Manager::unique_table[f].low;
+    return ClassProject::Manager::unique_table[f].low;
 
 }
-    ClassProject::BDD_ID ClassProject::Manager::neg(BDD_ID a) {
+ClassProject::BDD_ID ClassProject::Manager::neg(BDD_ID a) {
 
-        return ite(a, 0, 1);
+    return ite(a, 0, 1);
 }
-    ClassProject::BDD_ID ClassProject::Manager::and2(BDD_ID a, BDD_ID b){
+ClassProject::BDD_ID ClassProject::Manager::and2(BDD_ID a, BDD_ID b){
 
-        return ite(a, b, 0);
+    return ite(a, b, 0);
 }
-    ClassProject::BDD_ID ClassProject::Manager::or2(BDD_ID a, BDD_ID b){
+ClassProject::BDD_ID ClassProject::Manager::or2(BDD_ID a, BDD_ID b){
 
-        return ite(a, 1, b);
+    return ite(a, 1, b);
 }
-    ClassProject::BDD_ID ClassProject::Manager::xor2(BDD_ID a, BDD_ID b){
-//        BDD_ID negB = neg(b);
-        return ite(a, neg(b), b);
+ClassProject::BDD_ID ClassProject::Manager::xor2(BDD_ID a, BDD_ID b){
+
+    return ite(a, neg(b), b);
 }
-    ClassProject::BDD_ID ClassProject::Manager::nand2(BDD_ID a, BDD_ID b){
-        return neg(and2(a, b));
+ClassProject::BDD_ID ClassProject::Manager::nand2(BDD_ID a, BDD_ID b){
+    return neg(and2(a, b));
 
 }
-    ClassProject::BDD_ID ClassProject::Manager::nor2(BDD_ID a, BDD_ID b){
-        BDD_ID Or = or2(a, b);
-        BDD_ID nor = neg(Or);
-        return nor;
+ClassProject::BDD_ID ClassProject::Manager::nor2(BDD_ID a, BDD_ID b){
+    BDD_ID Or = or2(a, b);
+    BDD_ID nor = neg(Or);
+    return nor;
 }
-    ClassProject::BDD_ID ClassProject::Manager::xnor2(BDD_ID a, BDD_ID b){
-        BDD_ID Xor = xor2(a, b);
-        BDD_ID xnor = neg(Xor);
-        return xnor;
+ClassProject::BDD_ID ClassProject::Manager::xnor2(BDD_ID a, BDD_ID b){
+    BDD_ID Xor = xor2(a, b);
+    BDD_ID xnor = neg(Xor);
+    return xnor;
 }
 
-    std::string ClassProject::Manager::getTopVarName(const BDD_ID &root) {
-        BDD_ID topVariable = topVar(root);
-        return ClassProject::Manager::unique_table[topVariable].label;
+std::string ClassProject::Manager::getTopVarName(const BDD_ID &root) {
+    BDD_ID topVariable = topVar(root);
+    return ClassProject::Manager::unique_table[topVariable].label;
 }
-    void ClassProject::Manager::findNodes(const BDD_ID &root, std::set<BDD_ID> &nodes_of_root) {
-        nodes_of_root.insert(root);
-        if(root > 1) {
-            findNodes(coFactorTrue(root), nodes_of_root);
-            findNodes(coFactorFalse(root), nodes_of_root);
-        }
+void ClassProject::Manager::findNodes(const BDD_ID &root, std::set<BDD_ID> &nodes_of_root) {
+    nodes_of_root.insert(root);
+    if(root > 1) {
+        findNodes(coFactorTrue(root), nodes_of_root);
+        findNodes(coFactorFalse(root), nodes_of_root);
+    }
 
 }
 
-    void ClassProject::Manager::findVars(const BDD_ID &root, std::set<BDD_ID> &vars_of_root) {
-        std::set<BDD_ID> nodes;
-        findNodes(root, nodes);
-        nodes.erase(1);
-        nodes.erase(0);
-        for(auto x: nodes){
-            vars_of_root.insert(topVar(x));
-        }
+void ClassProject::Manager::findVars(const BDD_ID &root, std::set<BDD_ID> &vars_of_root) {
+    std::set<BDD_ID> nodes;
+    findNodes(root, nodes);
+    nodes.erase(1);
+    nodes.erase(0);
+    for(auto x: nodes){
+        vars_of_root.insert(topVar(x));
+    }
 
-}
-
+}
\ No newline at end of file
